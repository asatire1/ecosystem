<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-select=none">
    <title>Ecosystem Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1e293b;
            color: white;
            overflow: hidden;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 500px;
            margin: 0 auto;
        }
        
        /* Top Bar */
        #top-bar {
            background: linear-gradient(to bottom, #475569, #334155);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
        
        #top-bar h1 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .icon-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            opacity: 0.8;
        }
        
        .icon-btn:hover {
            opacity: 1;
        }
        
        /* Field */
        #field-container {
            flex: 1;
            position: relative;
            background: linear-gradient(to bottom, #87ceeb 0%, #90ee90 50%, #8b7355 100%);
            overflow: hidden;
        }
        
        #field {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .trial-zone {
            position: absolute;
            border: 2px dashed;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .trial-zone.visible {
            opacity: 0.3;
        }
        
        .safe-zone {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
        }
        
        .risk-zone {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }
        
        .organism {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
            font-size: 8px;
        }
        
        .grass {
            background: #22c55e;
            border: 1px solid #16a34a;
        }
        
        .rabbit {
            background: #fb923c;
            border: 2px solid #ea580c;
        }
        
        .rabbit.hungry {
            background: #fed7aa;
            border-color: #fdba74;
            opacity: 0.6;
        }
        
        .fox {
            background: #ef4444;
            border: 2px solid #dc2626;
        }
        
        .fox.hungry {
            background: #fca5a5;
            border-color: #f87171;
            opacity: 0.6;
        }
        
        /* Stats Bar */
        #stats-bar {
            background: #1e293b;
            padding: 12px 16px;
            display: flex;
            justify-content: space-around;
            height: 60px;
            align-items: center;
            font-size: 14px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.7;
        }
        
        .stat-value {
            font-weight: 600;
            font-size: 16px;
        }
        
        /* Controls Panel */
        #controls-panel {
            background: #334155;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .tool-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #475569;
            background: #475569;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tool-btn.active {
            border-color: currentColor;
            box-shadow: 0 0 0 2px currentColor;
        }
        
        .tool-btn.grass-btn { color: #22c55e; }
        .tool-btn.rabbit-btn { color: #fb923c; }
        .tool-btn.fox-btn { color: #ef4444; }
        
        .action-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .primary-btn {
            background: #3b82f6;
            color: white;
        }
        
        .secondary-btn {
            background: #64748b;
            color: white;
        }
        
        .action-btn:active {
            transform: scale(0.95);
        }
        
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
            background: #64748b;
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: #3b82f6;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: left 0.3s;
        }
        
        .toggle-switch.active::after {
            left: 23px;
        }
        
        .speed-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .speed-slider {
            width: 100%;
            height: 4px;
            background: #64748b;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }
        
        .speed-markers {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal.visible {
            display: flex;
        }
        
        .modal-content {
            background: #334155;
            padding: 24px;
            border-radius: 12px;
            max-width: 320px;
            text-align: center;
        }
        
        .modal-content h2 {
            margin-bottom: 12px;
            font-size: 24px;
        }
        
        .modal-content p {
            margin-bottom: 20px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Top Bar -->
        <div id="top-bar">
            <button class="icon-btn" onclick="showInfo()">‚ÑπÔ∏è</button>
            <h1 id="phase-title">Setup Phase</h1>
            <div style="display: flex; gap: 8px;">
                <button class="icon-btn" id="graph-btn" style="display: none;" onclick="toggleGraphs()">üìä</button>
            </div>
        </div>
        
        <!-- Field -->
        <div id="field-container">
            <div id="field">
                <div class="trial-zone safe-zone" id="safe-zone"></div>
                <div class="trial-zone risk-zone" id="risk-zone-tl"></div>
                <div class="trial-zone risk-zone" id="risk-zone-tr"></div>
                <div class="trial-zone risk-zone" id="risk-zone-bl"></div>
                <div class="trial-zone risk-zone" id="risk-zone-br"></div>
            </div>
        </div>
        
        <!-- Stats Bar -->
        <div id="stats-bar">
            <div class="stat">
                <div class="stat-label">Grass</div>
                <div class="stat-value" style="color: #22c55e;" id="grass-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Rabbits</div>
                <div class="stat-value" style="color: #fb923c;" id="rabbit-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Foxes</div>
                <div class="stat-value" style="color: #ef4444;" id="fox-count">0</div>
            </div>
            <div class="stat" id="time-stat" style="display: none;">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="time-value">0s</div>
            </div>
        </div>
        
        <!-- Controls Panel -->
        <div id="controls-panel">
            <div id="setup-controls">
                <div class="control-row">
                    <span style="font-size: 13px;">Trial Mode</span>
                    <div class="toggle-switch" id="trial-toggle" onclick="toggleTrialMode()"></div>
                </div>
                <div class="control-row">
                    <button class="tool-btn grass-btn active" onclick="selectTool('grass')">üå± Grass</button>
                    <button class="tool-btn rabbit-btn" onclick="selectTool('rabbit')">üê∞ Rabbit</button>
                    <button class="tool-btn fox-btn" onclick="selectTool('fox')">ü¶ä Fox</button>
                </div>
                <div class="control-row">
                    <button class="action-btn primary-btn" onclick="startSimulation()">Start Simulation</button>
                    <button class="action-btn secondary-btn" onclick="clearField()">Clear</button>
                </div>
            </div>
            
            <div id="playing-controls" style="display: none;">
                <div class="control-row">
                    <button class="action-btn primary-btn" id="pause-btn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
                    <button class="action-btn secondary-btn" onclick="resetGame()">üîÑ Reset</button>
                </div>
                <div class="speed-control">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 13px;">Speed</span>
                        <span id="speed-value" style="font-size: 13px; font-weight: 600;">1.0x</span>
                    </div>
                    <input type="range" min="0.5" max="4" step="0.5" value="1" id="speed-slider" 
                           style="width: 100%;" onchange="updateSpeed(this.value)">
                    <div class="speed-markers">
                        <span>0.5x</span>
                        <span>1x</span>
                        <span>2x</span>
                        <span>4x</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal" id="victory-modal">
        <div class="modal-content">
            <h2>üèÜ Victory!</h2>
            <p>Your ecosystem survived for 10 days!</p>
            <button class="action-btn primary-btn" onclick="resetGame()">Play Again</button>
        </div>
    </div>
    
    <div class="modal" id="gameover-modal">
        <div class="modal-content">
            <h2>üíÄ Ecosystem Collapsed</h2>
            <p id="gameover-reason"></p>
            <button class="action-btn primary-btn" onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <script>
        // Game state
        const GRID_SIZE = 20;
        const VICTORY_TIME = 300; // 10 days * 30 seconds
        let gameState = {
            phase: 'setup',
            gameTime: 0,
            speed: 1.0,
            isPaused: false,
            trialMode: false,
            selectedTool: 'grass',
            organisms: [],
            grid: [],
            nextId: 0,
            isPlacing: false,
            lastPlaceTime: 0
        };
        
        let tileSize = 0;
        let fieldWidth = 0;
        let fieldHeight = 0;
        let animationFrame = null;
        let lastUpdate = 0;
        
        // Initialize grid
        function initGrid() {
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    gameState.grid.push({
                        x, y,
                        groundLayer: null,
                        animalLayer: null,
                        grassId: null,
                        animalId: null
                    });
                }
            }
        }
        
        function getTile(x, y) {
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return null;
            return gameState.grid[y * GRID_SIZE + x];
        }
        
        // Calculate field dimensions
        function calculateDimensions() {
            const field = document.getElementById('field');
            fieldWidth = field.clientWidth;
            fieldHeight = field.clientHeight;
            tileSize = Math.min(fieldWidth / GRID_SIZE, fieldHeight / GRID_SIZE);
            
            // Position trial zones
            const safeSize = tileSize * GRID_SIZE * 0.5;
            const riskSize = tileSize * GRID_SIZE * 0.25;
            
            const safe = document.getElementById('safe-zone');
            safe.style.width = safeSize + 'px';
            safe.style.height = safeSize + 'px';
            safe.style.left = (fieldWidth - safeSize) / 2 + 'px';
            safe.style.top = (fieldHeight - safeSize) / 2 + 'px';
            
            document.getElementById('risk-zone-tl').style.cssText = 
                `width: ${riskSize}px; height: ${riskSize}px; left: 0; top: 0;`;
            document.getElementById('risk-zone-tr').style.cssText = 
                `width: ${riskSize}px; height: ${riskSize}px; right: 0; top: 0;`;
            document.getElementById('risk-zone-bl').style.cssText = 
                `width: ${riskSize}px; height: ${riskSize}px; left: 0; bottom: 0;`;
            document.getElementById('risk-zone-br').style.cssText = 
                `width: ${riskSize}px; height: ${riskSize}px; right: 0; bottom: 0;`;
        }
        
        // Tool selection
        function selectTool(tool) {
            gameState.selectedTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.${tool}-btn`).classList.add('active');
        }
        
        function toggleTrialMode() {
            gameState.trialMode = !gameState.trialMode;
            document.getElementById('trial-toggle').classList.toggle('active');
            document.querySelectorAll('.trial-zone').forEach(zone => {
                zone.classList.toggle('visible');
            });
        }
        
        // Organism creation
        function createOrganism(type, x, y) {
            const tile = getTile(x, y);
            if (!tile) return null;
            
            // Check layer rules
            if (type === 'grass') {
                if (tile.groundLayer) return null; // Already has grass
            } else {
                if (tile.animalLayer) return null; // Already has animal
            }
            
            const org = {
                id: gameState.nextId++,
                type: type,
                x: x,
                y: y,
                health: 100,
                hungerTimer: 0,
                reproductionCooldown: type === 'rabbit' ? 40 : 90,
                isAlive: true,
                element: null
            };
            
            // Update tile
            if (type === 'grass') {
                tile.groundLayer = 'grass';
                tile.grassId = org.id;
            } else {
                tile.animalLayer = type;
                tile.animalId = org.id;
            }
            
            gameState.organisms.push(org);
            createOrganismElement(org);
            updateCounts();
            return org;
        }
        
        function createOrganismElement(org) {
            const el = document.createElement('div');
            el.className = `organism ${org.type}`;
            const size = org.type === 'grass' ? tileSize * 0.1 : 
                         org.type === 'rabbit' ? tileSize * 0.25 : tileSize * 0.5;
            el.style.width = size + 'px';
            el.style.height = size + 'px';
            el.style.fontSize = (size * 0.6) + 'px';
            el.textContent = org.type === 'grass' ? 'üå±' : org.type === 'rabbit' ? 'üê∞' : 'ü¶ä';
            document.getElementById('field').appendChild(el);
            org.element = el;
            updateOrganismPosition(org);
        }
        
        function updateOrganismPosition(org) {
            if (!org.element) return;
            const size = org.type === 'grass' ? tileSize * 0.1 : 
                         org.type === 'rabbit' ? tileSize * 0.25 : tileSize * 0.5;
            org.element.style.left = (org.x * tileSize + tileSize/2 - size/2) + 'px';
            org.element.style.top = (org.y * tileSize + tileSize/2 - size/2) + 'px';
        }
        
        // Placement handling
        function handleFieldTouch(e) {
            if (gameState.phase !== 'setup') return;
            
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = document.getElementById('field').getBoundingClientRect();
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);
            
            const now = Date.now();
            if (now - gameState.lastPlaceTime > 100) {
                createOrganism(gameState.selectedTool, x, y);
                gameState.lastPlaceTime = now;
            }
        }
        
        // Game controls
        function startSimulation() {
            if (gameState.organisms.length === 0) return;
            
            gameState.phase = 'playing';
            gameState.gameTime = 0;
            document.getElementById('phase-title').textContent = 'Ecosystem';
            document.getElementById('setup-controls').style.display = 'none';
            document.getElementById('playing-controls').style.display = 'block';
            document.getElementById('time-stat').style.display = 'flex';
            document.getElementById('graph-btn').style.display = 'block';
            
            lastUpdate = Date.now();
            gameLoop();
        }
        
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            const btn = document.getElementById('pause-btn');
            btn.textContent = gameState.isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        }
        
        function updateSpeed(value) {
            gameState.speed = parseFloat(value);
            document.getElementById('speed-value').textContent = value + 'x';
        }
        
        function clearField() {
            gameState.organisms.forEach(org => {
                if (org.element) org.element.remove();
            });
            gameState.organisms = [];
            initGrid();
            updateCounts();
        }
        
        function resetGame() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            clearField();
            gameState.phase = 'setup';
            gameState.gameTime = 0;
            gameState.isPaused = false;
            document.getElementById('phase-title').textContent = 'Setup Phase';
            document.getElementById('setup-controls').style.display = 'block';
            document.getElementById('playing-controls').style.display = 'none';
            document.getElementById('time-stat').style.display = 'none';
            document.getElementById('graph-btn').style.display = 'none';
            document.getElementById('victory-modal').classList.remove('visible');
            document.getElementById('gameover-modal').classList.remove('visible');
        }
        
        // Game loop
        function gameLoop() {
            if (gameState.phase !== 'playing') return;
            
            const now = Date.now();
            const deltaTime = (now - lastUpdate) / 1000 * gameState.speed;
            lastUpdate = now;
            
            if (!gameState.isPaused) {
                gameState.gameTime += deltaTime;
                updateGame(deltaTime);
                checkWinLoss();
            }
            
            updateUI();
            animationFrame = requestAnimationFrame(gameLoop);
        }
        
        function updateGame(dt) {
            // Update organisms
            gameState.organisms.forEach(org => {
                if (!org.isAlive) return;
                
                if (org.type === 'rabbit') {
                    updateRabbit(org, dt);
                } else if (org.type === 'fox') {
                    updateFox(org, dt);
                }
            });
            
            // Grass growth (every 5 seconds)
            if (Math.random() < dt / 5) {
                growGrass();
            }
            
            // Remove dead organisms
            gameState.organisms = gameState.organisms.filter(org => {
                if (!org.isAlive) {
                    if (org.element) org.element.remove();
                    const tile = getTile(org.x, org.y);
                    if (tile) {
                        if (org.type === 'grass') {
                            tile.groundLayer = null;
                            tile.grassId = null;
                        } else {
                            tile.animalLayer = null;
                            tile.animalId = null;
                        }
                    }
                    return false;
                }
                return true;
            });
        }
        
        function updateRabbit(rabbit, dt) {
            rabbit.hungerTimer += dt;
            rabbit.reproductionCooldown -= dt;
            
            // Update visual hunger state
            if (rabbit.hungerTimer > 6) {
                rabbit.element.classList.add('hungry');
            } else {
                rabbit.element.classList.remove('hungry');
            }
            
            // Death from starvation
            if (rabbit.hungerTimer > 12) {
                rabbit.isAlive = false;
                return;
            }
            
            // Movement
            const tile = getTile(rabbit.x, rabbit.y);
            if (tile && tile.groundLayer === 'grass') {
                // Eat grass on current tile
                tile.groundLayer = null;
                const grassOrg = gameState.organisms.find(o => o.id === tile.grassId);
                if (grassOrg) grassOrg.isAlive = false;
                tile.grassId = null;
                rabbit.hungerTimer = 0;
            } else if (rabbit.hungerTimer > 6) {
                // Look for grass
                const nearestGrass = findNearestGrass(rabbit.x, rabbit.y, 3);
                if (nearestGrass) {
                    moveTowards(rabbit, nearestGrass.x, nearestGrass.y, dt * 2);
                } else {
                    moveRandom(rabbit, dt * 2);
                }
            } else {
                moveRandom(rabbit, dt * 2);
            }
            
            // Reproduction
            if (rabbit.reproductionCooldown <= 0 && rabbit.hungerTimer < 6) {
                reproduceRabbit(rabbit);
            }
            
            updateOrganismPosition(rabbit);
        }
        
        function updateFox(fox, dt) {
            fox.hungerTimer += dt;
            fox.reproductionCooldown -= dt;
            
            // Update visual hunger state
            if (fox.hungerTimer > 10) {
                fox.element.classList.add('hungry');
            } else {
                fox.element.classList.remove('hungry');
            }
            
            // Death from starvation
            if (fox.hungerTimer > 25) {
                fox.isAlive = false;
                return;
            }
            
            // Check if on tile with rabbit
            const tile = getTile(fox.x, fox.y);
            const rabbitHere = gameState.organisms.find(o => 
                o.type === 'rabbit' && o.isAlive && o.x === fox.x && o.y === fox.y && o.id !== fox.id
            );
            
            if (rabbitHere) {
                rabbitHere.isAlive = false;
                fox.hungerTimer = 0;
            } else if (fox.hungerTimer > 10) {
                // Hunt for rabbits
                const nearestRabbit = findNearestRabbit(fox.x, fox.y, 5);
                if (nearestRabbit) {
                    moveTowards(fox, nearestRabbit.x, nearestRabbit.y, dt * 4);
                } else {
                    moveRandom(fox, dt * 4);
                }
            } else {
                moveRandom(fox, dt * 4);
            }
            
            // Reproduction
            if (fox.reproductionCooldown <= 0 && fox.hungerTimer < 10) {
                reproduceFox(fox);
            }
            
            updateOrganismPosition(fox);
        }
        
        function moveTowards(org, targetX, targetY, speed) {
            const dx = targetX - org.x;
            const dy = targetY - org.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.1) return;
            
            const newX = org.x + (dx / dist) * speed;
            const newY = org.y + (dy / dist) * speed;
            
            moveOrganism(org, Math.round(newX), Math.round(newY));
        }
        
        function moveRandom(org, speed) {
            const angle = Math.random() * Math.PI * 2;
            const newX = Math.round(org.x + Math.cos(angle) * speed);
            const newY = Math.round(org.y + Math.sin(angle) * speed);
            moveOrganism(org, newX, newY);
        }
        
        function moveOrganism(org, newX, newY) {
            newX = Math.max(0, Math.min(GRID_SIZE - 1, newX));
            newY = Math.max(0, Math.min(GRID_SIZE - 1, newY));
            
            if (newX === org.x && newY === org.y) return;
            
            const newTile = getTile(newX, newY);
            if (!newTile) return;
            
            // Check if can move
            if (org.type === 'rabbit' && newTile.animalLayer === 'fox') return;
            if (org.type === 'fox' && newTile.animalLayer === 'fox') return;
            
            // Update old tile
            const oldTile = getTile(org.x, org.y);
            if (oldTile) {
                oldTile.animalLayer = null;
                oldTile.animalId = null;
            }
            
            // Update position
            org.x = newX;
            org.y = newY;
            
            // Update new tile
            newTile.animalLayer = org.type;
            newTile.animalId = org.id;
        }
        
        function findNearestGrass(x, y, range) {
            let nearest = null;
            let minDist = range + 1;
            
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    const tile = getTile(x + dx, y + dy);
                    if (tile && tile.groundLayer === 'grass') {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = tile;
                        }
                    }
                }
            }
            
            return nearest;
        }
        
        function findNearestRabbit(x, y, range) {
            let nearest = null;
            let minDist = range + 1;
            
            gameState.organisms.forEach(org => {
                if (org.type === 'rabbit' && org.isAlive) {
                    const dx = org.x - x;
                    const dy = org.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist && dist <= range) {
                        minDist = dist;
                        nearest = org;
                    }
                }
            });
            
            return nearest;
        }
        
        function reproduceRabbit(rabbit) {
            // Find empty adjacent tile
            const adjacent = [
                {x: rabbit.x - 1, y: rabbit.y},
                {x: rabbit.x + 1, y: rabbit.y},
                {x: rabbit.x, y: rabbit.y - 1},
                {x: rabbit.x, y: rabbit.y + 1}
            ];
            
            for (let pos of adjacent) {
                const tile = getTile(pos.x, pos.y);
                if (tile && !tile.animalLayer) {
                    // Check density
                    let nearbyRabbits = 0;
                    for (let dy = -5; dy <= 5; dy++) {
                        for (let dx = -5; dx <= 5; dx++) {
                            const checkTile = getTile(pos.x + dx, pos.y + dy);
                            if (checkTile && checkTile.animalLayer === 'rabbit') {
                                nearbyRabbits++;
                            }
                        }
                    }
                    
                    if (nearbyRabbits < 8) {
                        createOrganism('rabbit', pos.x, pos.y);
                        rabbit.reproductionCooldown = 40;
                        return;
                    }
                }
            }
        }
        
        function reproduceFox(fox) {
            // Count nearby rabbits
            let nearbyRabbits = 0;
            for (let dy = -8; dy <= 8; dy++) {
                for (let dx = -8; dx <= 8; dx++) {
                    const tile = getTile(fox.x + dx, fox.y + dy);
                    if (tile && tile.animalLayer === 'rabbit') {
                        nearbyRabbits++;
                    }
                }
            }
            
            if (nearbyRabbits < 3) return;
            
            // Find empty adjacent tile
            const adjacent = [
                {x: fox.x - 1, y: fox.y},
                {x: fox.x + 1, y: fox.y},
                {x: fox.x, y: fox.y - 1},
                {x: fox.x, y: fox.y + 1}
            ];
            
            for (let pos of adjacent) {
                const tile = getTile(pos.x, pos.y);
                if (tile && !tile.animalLayer) {
                    // Check density
                    let nearbyFoxes = 0;
                    for (let dy = -5; dy <= 5; dy++) {
                        for (let dx = -5; dx <= 5; dx++) {
                            const checkTile = getTile(pos.x + dx, pos.y + dy);
                            if (checkTile && checkTile.animalLayer === 'fox') {
                                nearbyFoxes++;
                            }
                        }
                    }
                    
                    if (nearbyFoxes < 4) {
                        createOrganism('fox', pos.x, pos.y);
                        fox.reproductionCooldown = 90;
                        return;
                    }
                }
            }
        }
        
        function growGrass() {
            const grassTiles = [];
            gameState.grid.forEach(tile => {
                if (tile.groundLayer === 'grass') grassTiles.push(tile);
            });
            
            if (grassTiles.length === 0) return;
            
            // Check 70% limit
            const maxGrass = Math.floor(GRID_SIZE * GRID_SIZE * 0.7);
            if (grassTiles.length >= maxGrass) return;
            
            // Pick random grass tile to spread from
            const sourceTile = grassTiles[Math.floor(Math.random() * grassTiles.length)];
            
            // Try adjacent tiles
            const adjacent = [
                getTile(sourceTile.x - 1, sourceTile.y),
                getTile(sourceTile.x + 1, sourceTile.y),
                getTile(sourceTile.x, sourceTile.y - 1),
                getTile(sourceTile.x, sourceTile.y + 1)
            ].filter(t => t && !t.groundLayer);
            
            if (adjacent.length > 0) {
                const targetTile = adjacent[Math.floor(Math.random() * adjacent.length)];
                createOrganism('grass', targetTile.x, targetTile.y);
            }
        }
        
        function updateCounts() {
            const counts = {grass: 0, rabbit: 0, fox: 0};
            gameState.organisms.forEach(org => {
                if (org.isAlive) counts[org.type]++;
            });
            
            document.getElementById('grass-count').textContent = counts.grass;
            document.getElementById('rabbit-count').textContent = counts.rabbit;
            document.getElementById('fox-count').textContent = counts.fox;
        }
        
        function updateUI() {
            updateCounts();
            const minutes = Math.floor(gameState.gameTime / 60);
            const seconds = Math.floor(gameState.gameTime % 60);
            document.getElementById('time-value').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function checkWinLoss() {
            const counts = {grass: 0, rabbit: 0, fox: 0};
            gameState.organisms.forEach(org => {
                if (org.isAlive) counts[org.type]++;
            });
            
            // Check for extinction
            if (counts.grass === 0) {
                endGame(false, 'All grass was consumed! The ecosystem collapsed.');
            } else if (counts.rabbit === 0) {
                endGame(false, 'All rabbits died! Foxes will soon follow.');
            } else if (counts.fox === 0) {
                endGame(false, 'All foxes died! The ecosystem is incomplete.');
            } else if (gameState.gameTime >= VICTORY_TIME) {
                endGame(true, '');
            }
        }
        
        function endGame(victory, reason) {
            gameState.phase = 'ended';
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            if (victory) {
                document.getElementById('victory-modal').classList.add('visible');
            } else {
                document.getElementById('gameover-reason').textContent = reason;
                document.getElementById('gameover-modal').classList.add('visible');
            }
        }
        
        function showInfo() {
            alert('Ecosystem Simulation\n\nCreate a balanced ecosystem:\n‚Ä¢ Place grass (producers)\n‚Ä¢ Add rabbits (herbivores)\n‚Ä¢ Add foxes (predators)\n\nGoal: Survive 10 days (5 minutes)\n\nTip: Use Trial Mode to see optimal placement zones. Balance is key!');
        }
        
        function toggleGraphs() {
            // Placeholder for graph toggle
            alert('Graph feature coming soon!');
        }
        
        // Initialize
        window.addEventListener('load', () => {
            initGrid();
            calculateDimensions();
            
            const field = document.getElementById('field');
            field.addEventListener('mousedown', () => gameState.isPlacing = true);
            field.addEventListener('mouseup', () => gameState.isPlacing = false);
            field.addEventListener('mousemove', (e) => {
                if (gameState.isPlacing) handleFieldTouch(e);
            });
            field.addEventListener('mousedown', handleFieldTouch);
            
            field.addEventListener('touchstart', (e) => {
                gameState.isPlacing = true;
                handleFieldTouch(e);
            });
            field.addEventListener('touchmove', handleFieldTouch);
            field.addEventListener('touchend', () => gameState.isPlacing = false);
            
            window.addEventListener('resize', () => {
                calculateDimensions();
                gameState.organisms.forEach(updateOrganismPosition);
            });
        });
    </script>
</body>
</html>
