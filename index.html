<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Simulation Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e293b;
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(to bottom, #475569, #334155);
        }
        
        .top-bar h1 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .icon-group {
            display: flex;
            gap: 8px;
        }
        
        .icon {
            width: 24px;
            height: 24px;
            opacity: 0.8;
            cursor: pointer;
        }
        
        .game-field {
            flex: 1;
            position: relative;
            background: #90ee90;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 12px 16px;
            background: #0f172a;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .controls-panel {
            padding: 16px;
            background: #475569;
        }
        
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .toggle-switch {
            width: 48px;
            height: 28px;
            background: #64748b;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: #3b82f6;
        }
        
        .toggle-knob {
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
        }
        
        .toggle-switch.active .toggle-knob {
            transform: translateX(20px);
        }
        
        .tool-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .tool-btn {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #64748b;
            background: #334155;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tool-btn.active-grass {
            border-color: #22c55e;
        }
        
        .tool-btn.active-rabbit {
            border-color: #fb923c;
        }
        
        .tool-btn.active-fox {
            border-color: #ef4444;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: #64748b;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #475569;
        }
        
        .speed-control {
            margin-top: 12px;
        }
        
        .speed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .speed-slider {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .speed-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .speed-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            opacity: 0.7;
            margin-top: 4px;
        }
        
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 1000;
        }
        
        .modal-content {
            background: #334155;
            border-radius: 12px;
            padding: 32px;
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        
        .modal-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .modal-text {
            color: #cbd5e1;
            margin-bottom: 24px;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <span class="icon">‚öôÔ∏è</span>
        <h1 id="phase-title">SETUP PHASE</h1>
        <div class="icon-group">
            <span class="icon">‚ÑπÔ∏è</span>
            <span class="icon hidden" id="graph-icon">üìä</span>
            <span class="icon hidden" id="map-icon">üìç</span>
        </div>
    </div>

    <div class="game-field">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="stats-bar">
        <div class="stat">
            <div class="stat-label">Grass</div>
            <div class="stat-value" style="color: #22c55e;" id="grass-count">[0]</div>
        </div>
        <div class="stat">
            <div class="stat-label">Rabbits</div>
            <div class="stat-value" style="color: #fb923c;" id="rabbit-count">[0]</div>
        </div>
        <div class="stat">
            <div class="stat-label">Foxes</div>
            <div class="stat-value" style="color: #ef4444;" id="fox-count">[0]</div>
        </div>
        <div class="stat hidden" id="time-stat">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="time-value">[0:00]</div>
        </div>
    </div>

    <div class="controls-panel">
        <div id="setup-controls">
            <div class="toggle-row">
                <span>Trial Mode</span>
                <div class="toggle-switch" id="trial-toggle">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            
            <div class="tool-buttons">
                <button class="tool-btn active-grass" data-tool="grass">üå± Grass</button>
                <button class="tool-btn" data-tool="rabbit">üê∞ Rabbit</button>
                <button class="tool-btn" data-tool="fox">ü¶ä Fox</button>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" id="start-btn">START SIMULATION</button>
                <button class="btn btn-secondary" id="clear-btn">CLEAR</button>
            </div>
        </div>

        <div id="playing-controls" class="hidden">
            <div class="action-buttons" style="margin-bottom: 12px;">
                <button class="btn btn-secondary" id="pause-btn">‚è∏Ô∏è PAUSE</button>
                <button class="btn btn-secondary" id="reset-btn">üîÑ RESET</button>
            </div>
            
            <div class="speed-control">
                <div class="speed-header">
                    <span>Speed</span>
                    <span id="speed-value">1.0x</span>
                </div>
                <input type="range" class="speed-slider" id="speed-slider" min="0.5" max="4" step="0.5" value="1">
                <div class="speed-labels">
                    <span>0.5x</span>
                    <span>1x</span>
                    <span>2x</span>
                    <span>4x</span>
                </div>
            </div>
        </div>
    </div>

    <div id="modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-icon" id="modal-icon">üèÜ</div>
            <h2 class="modal-title" id="modal-title">Victory!</h2>
            <p class="modal-text" id="modal-text">Your ecosystem survived for 10 days!</p>
            <button class="btn btn-primary" id="modal-btn" style="width: 100%;">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 20;
        const TILE_COUNT = GRID_SIZE * GRID_SIZE;
        const GAME_DAY_SECONDS = 30;
        const WIN_DAYS = 10;
        const FRAME_RATE = 60;

        const GRASS_GROWTH_INTERVAL = 2;
        const GRASS_MAX_COVERAGE = 0.7;
        const GRASS_REGROW_TIME = 15;

        const RABBIT_SPEED = 2;
        const RABBIT_DETECTION = 3;
        const RABBIT_HUNGER_WARNING = 6;
        const RABBIT_HUNGER_MAX = 12;
        const RABBIT_REPRODUCE_COOLDOWN = 10;
        const RABBIT_DENSITY_LIMIT = 8;
        const RABBIT_DENSITY_RADIUS = 5;

        const FOX_SPEED = 4;
        const FOX_DETECTION = 5;
        const FOX_HUNGER_WARNING = 10;
        const FOX_HUNGER_MAX = 25;
        const FOX_REPRODUCE_COOLDOWN = 30;
        const FOX_DENSITY_LIMIT = 4;
        const FOX_DENSITY_RADIUS = 5;
        const FOX_REPRODUCE_RABBIT_REQUIREMENT = 3;
        const FOX_REPRODUCE_RABBIT_RADIUS = 8;

        let gamePhase = 'setup';
        let selectedTool = 'grass';
        let trialMode = false;
        let speed = 1;
        let gameTime = 0;
        let grid = [];
        let animals = [];
        let nextId = 1;
        let animationFrameId = null;
        let lastUpdate = 0;
        let logicFrame = 0;
        let grassGrowthTimer = 0;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function initializeGrid() {
            grid = Array(TILE_COUNT).fill(null).map(() => ({
                grass: false,
                grassGrowTime: 0
            }));
            animals = [];
            gameTime = 0;
            nextId = 1;
        }

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.width;
        }

        function getTileIndex(x, y) {
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return -1;
            return Math.floor(y) * GRID_SIZE + Math.floor(x);
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function findNearestTarget(animal, targets, range) {
            let nearest = null;
            let minDist = range;
            
            targets.forEach(target => {
                const dist = getDistance(animal.x, animal.y, target.x, target.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = target;
                }
            });
            
            return nearest;
        }

        function moveToward(animal, targetX, targetY, speedPerFrame) {
            const dx = targetX - animal.x;
            const dy = targetY - animal.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < speedPerFrame) {
                animal.x = targetX;
                animal.y = targetY;
            } else {
                animal.x += (dx / dist) * speedPerFrame;
                animal.y += (dy / dist) * speedPerFrame;
            }
            
            animal.x = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.x));
            animal.y = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.y));
        }

        function countNearbyAnimals(x, y, type, radius) {
            return animals.filter(a => 
                a.type === type && getDistance(x, y, a.x, a.y) <= radius
            ).length;
        }

        function getAdjacentEmptyTile(x, y) {
            const adjacent = [
                {x: x + 1, y: y}, {x: x - 1, y: y}, {x: x, y: y + 1}, {x: x, y: y - 1},
                {x: x + 1, y: y + 1}, {x: x - 1, y: y - 1}, {x: x + 1, y: y - 1}, {x: x - 1, y: y + 1}
            ];
            
            for (let pos of adjacent) {
                if (pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE) {
                    const occupied = animals.some(a => 
                        Math.floor(a.x) === Math.floor(pos.x) && Math.floor(a.y) === Math.floor(pos.y)
                    );
                    if (!occupied) return pos;
                }
            }
            return null;
        }

        function updateLogic(deltaTime) {
            if (gamePhase !== 'playing') return;

            const speedPerFrame = deltaTime * speed;
            
            animals.forEach(animal => {
                animal.hunger += deltaTime * speed;
                animal.reproduceCooldown = Math.max(0, animal.reproduceCooldown - deltaTime * speed);
                
                if (animal.type === 'rabbit') {
                    const currentTileIdx = getTileIndex(animal.x, animal.y);
                    
                    if (currentTileIdx >= 0 && grid[currentTileIdx].grass) {
                        grid[currentTileIdx].grass = false;
                        grid[currentTileIdx].grassGrowTime = GRASS_REGROW_TIME;
                        animal.hunger = 0;
                    } else if (animal.hunger > RABBIT_HUNGER_WARNING) {
                        const nearbyGrass = [];
                        for (let dy = -RABBIT_DETECTION; dy <= RABBIT_DETECTION; dy++) {
                            for (let dx = -RABBIT_DETECTION; dx <= RABBIT_DETECTION; dx++) {
                                const checkX = Math.floor(animal.x) + dx;
                                const checkY = Math.floor(animal.y) + dy;
                                const idx = getTileIndex(checkX, checkY);
                                if (idx >= 0 && grid[idx].grass) {
                                    nearbyGrass.push({ x: checkX + 0.5, y: checkY + 0.5 });
                                }
                            }
                        }
                        
                        if (nearbyGrass.length > 0) {
                            const nearest = findNearestTarget(animal, nearbyGrass, RABBIT_DETECTION);
                            if (nearest) {
                                moveToward(animal, nearest.x, nearest.y, RABBIT_SPEED * speedPerFrame / FRAME_RATE);
                            }
                        } else {
                            animal.x += (Math.random() - 0.5) * RABBIT_SPEED * speedPerFrame / FRAME_RATE;
                            animal.y += (Math.random() - 0.5) * RABBIT_SPEED * speedPerFrame / FRAME_RATE;
                            animal.x = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.x));
                            animal.y = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.y));
                        }
                    } else {
                        animal.x += (Math.random() - 0.5) * RABBIT_SPEED * speedPerFrame / FRAME_RATE;
                        animal.y += (Math.random() - 0.5) * RABBIT_SPEED * speedPerFrame / FRAME_RATE;
                        animal.x = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.x));
                        animal.y = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.y));
                    }
                    
                    if (animal.reproduceCooldown <= 0 && animal.hunger < RABBIT_HUNGER_WARNING) {
                        const nearby = countNearbyAnimals(animal.x, animal.y, 'rabbit', RABBIT_DENSITY_RADIUS);
                        if (nearby < RABBIT_DENSITY_LIMIT) {
                            const emptyTile = getAdjacentEmptyTile(animal.x, animal.y);
                            if (emptyTile) {
                                animals.push({
                                    id: nextId++,
                                    type: 'rabbit',
                                    x: emptyTile.x,
                                    y: emptyTile.y,
                                    hunger: 0,
                                    reproduceCooldown: RABBIT_REPRODUCE_COOLDOWN
                                });
                                animal.reproduceCooldown = RABBIT_REPRODUCE_COOLDOWN;
                            }
                        }
                    }
                } else if (animal.type === 'fox') {
                    const rabbitsOnTile = animals.filter(a => 
                        a.type === 'rabbit' && 
                        Math.floor(a.x) === Math.floor(animal.x) && 
                        Math.floor(a.y) === Math.floor(animal.y)
                    );
                    
                    if (rabbitsOnTile.length > 0) {
                        animals = animals.filter(a => a.id !== rabbitsOnTile[0].id);
                        animal.hunger = 0;
                    } else if (animal.hunger > FOX_HUNGER_WARNING) {
                        const nearbyRabbits = animals.filter(a => 
                            a.type === 'rabbit' && getDistance(animal.x, animal.y, a.x, a.y) <= FOX_DETECTION
                        );
                        
                        if (nearbyRabbits.length > 0) {
                            const nearest = findNearestTarget(animal, nearbyRabbits, FOX_DETECTION);
                            if (nearest) {
                                moveToward(animal, nearest.x, nearest.y, FOX_SPEED * speedPerFrame / FRAME_RATE);
                            }
                        } else {
                            animal.x += (Math.random() - 0.5) * FOX_SPEED * speedPerFrame / FRAME_RATE * 0.5;
                            animal.y += (Math.random() - 0.5) * FOX_SPEED * speedPerFrame / FRAME_RATE * 0.5;
                            animal.x = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.x));
                            animal.y = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.y));
                        }
                    } else {
                        animal.x += (Math.random() - 0.5) * FOX_SPEED * speedPerFrame / FRAME_RATE * 0.5;
                        animal.y += (Math.random() - 0.5) * FOX_SPEED * speedPerFrame / FRAME_RATE * 0.5;
                        animal.x = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.x));
                        animal.y = Math.max(0, Math.min(GRID_SIZE - 0.01, animal.y));
                    }
                    
                    if (animal.reproduceCooldown <= 0 && animal.hunger < FOX_HUNGER_WARNING) {
                        const nearbyRabbits = countNearbyAnimals(animal.x, animal.y, 'rabbit', FOX_REPRODUCE_RABBIT_RADIUS);
                        const nearbyFoxes = countNearbyAnimals(animal.x, animal.y, 'fox', FOX_DENSITY_RADIUS);
                        
                        if (nearbyRabbits >= FOX_REPRODUCE_RABBIT_REQUIREMENT && nearbyFoxes < FOX_DENSITY_LIMIT) {
                            const emptyTile = getAdjacentEmptyTile(animal.x, animal.y);
                            if (emptyTile) {
                                animals.push({
                                    id: nextId++,
                                    type: 'fox',
                                    x: emptyTile.x,
                                    y: emptyTile.y,
                                    hunger: 0,
                                    reproduceCooldown: FOX_REPRODUCE_COOLDOWN
                                });
                                animal.reproduceCooldown = FOX_REPRODUCE_COOLDOWN;
                            }
                        }
                    }
                }
            });
            
            animals = animals.filter(animal => {
                if (animal.type === 'rabbit') return animal.hunger < RABBIT_HUNGER_MAX;
                if (animal.type === 'fox') return animal.hunger < FOX_HUNGER_MAX;
                return true;
            });

            grassGrowthTimer += deltaTime * speed;
            if (grassGrowthTimer >= GRASS_GROWTH_INTERVAL) {
                grassGrowthTimer = 0;
                
                const currentGrass = grid.filter(t => t.grass).length;
                const maxGrass = Math.floor(TILE_COUNT * GRASS_MAX_COVERAGE);
                
                grid.forEach(tile => {
                    if (tile.grassGrowTime > 0) {
                        tile.grassGrowTime = Math.max(0, tile.grassGrowTime - GRASS_GROWTH_INTERVAL * speed);
                        if (tile.grassGrowTime === 0) {
                            tile.grass = true;
                        }
                    }
                });
                
                if (currentGrass < maxGrass) {
                    const grassTiles = grid.map((t, i) => t.grass ? i : -1).filter(i => i >= 0);
                    
                    grassTiles.forEach(idx => {
                        if (Math.random() < 0.3 && currentGrass < maxGrass) {
                            const x = idx % GRID_SIZE;
                            const y = Math.floor(idx / GRID_SIZE);
                            const adjacent = [
                                getTileIndex(x + 1, y), getTileIndex(x - 1, y),
                                getTileIndex(x, y + 1), getTileIndex(x, y - 1)
                            ].filter(i => i >= 0 && !grid[i].grass && grid[i].grassGrowTime === 0);
                            
                            if (adjacent.length > 0) {
                                const targetIdx = adjacent[Math.floor(Math.random() * adjacent.length)];
                                grid[targetIdx].grass = true;
                            }
                        }
                    });
                }
            }

            gameTime += deltaTime * speed;
            
            if (gameTime >= WIN_DAYS * GAME_DAY_SECONDS) {
                gamePhase = 'ended';
                showModal('victory', 'Victory!', 'Your ecosystem survived for 10 days!');
                return;
            }

            checkGameOver();
        }

        function checkGameOver() {
            const grassCount = grid.filter(t => t.grass).length;
            const rabbitCount = animals.filter(a => a.type === 'rabbit').length;
            const foxCount = animals.filter(a => a.type === 'fox').length;
            
            if (grassCount === 0) {
                gamePhase = 'ended';
                showModal('gameover', 'Ecosystem Collapsed', 'All grass was consumed! The ecosystem collapsed.');
            } else if (rabbitCount === 0) {
                gamePhase = 'ended';
                showModal('gameover', 'Ecosystem Collapsed', 'All rabbits died! Foxes will soon follow.');
            } else if (foxCount === 0) {
                gamePhase = 'ended';
                showModal('gameover', 'Ecosystem Collapsed', 'All foxes died! The ecosystem is incomplete.');
            }
        }

        function render() {
            const tileSize = canvas.width / GRID_SIZE;
            
            ctx.fillStyle = '#90ee90';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gamePhase === 'setup' && trialMode) {
                ctx.strokeStyle = '#22c55e';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                const safeX = GRID_SIZE * 0.25 * tileSize;
                const safeY = GRID_SIZE * 0.25 * tileSize;
                const safeW = GRID_SIZE * 0.5 * tileSize;
                const safeH = GRID_SIZE * 0.5 * tileSize;
                ctx.strokeRect(safeX, safeY, safeW, safeH);
                
                ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
                ctx.fillRect(0, 0, safeX, safeY);
                ctx.fillRect(safeX + safeW, 0, canvas.width - (safeX + safeW), safeY);
                ctx.fillRect(0, safeY + safeH, safeX, canvas.height - (safeY + safeH));
                ctx.fillRect(safeX + safeW, safeY + safeH, canvas.width - (safeX + safeW), canvas.height - (safeY + safeH));
                
                ctx.setLineDash([]);
            }
            
            grid.forEach((tile, idx) => {
                if (tile.grass) {
                    const x = (idx % GRID_SIZE) * tileSize + tileSize / 2;
                    const y = Math.floor(idx / GRID_SIZE) * tileSize + tileSize / 2;
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(x, y, tileSize * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            animals.forEach(animal => {
                const x = animal.x * tileSize;
                const y = animal.y * tileSize;
                const size = animal.type === 'rabbit' ? tileSize * 0.25 : tileSize * 0.5;
                
                let color, borderColor, opacity;
                if (animal.type === 'rabbit') {
                    const hungry = animal.hunger > RABBIT_HUNGER_WARNING;
                    color = hungry ? '#fed7aa' : '#fb923c';
                    borderColor = hungry ? '#fdba74' : '#ea580c';
                    opacity = hungry ? 0.6 : 1;
                } else {
                    const hungry = animal.hunger > FOX_HUNGER_WARNING;
                    color = hungry ? '#fca5a5' : '#ef4444';
                    borderColor = hungry ? '#f87171' : '#dc2626';
                    opacity = hungry ? 0.6 : 1;
                }
                
                ctx.globalAlpha = opacity;
                ctx.fillStyle = color;
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function updateStats() {
            const grassCount = grid.filter(t => t.grass).length;
            const rabbitCount = animals.filter(a => a.type === 'rabbit').length;
            const foxCount = animals.filter(a => a.type === 'fox').length;
            
            document.getElementById('grass-count').textContent = `[${grassCount}]`;
            document.getElementById('rabbit-count').textContent = `[${rabbitCount}]`;
            document.getElementById('fox-count').textContent = `[${foxCount}]`;
            
            if (gamePhase === 'playing') {
                const mins = Math.floor(gameTime / 60);
                const secs = Math.floor(gameTime % 60);
                document.getElementById('time-value').textContent = `[${mins}:${secs.toString().padStart(2, '0')}]`;
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastUpdate) / 1000;
            lastUpdate = timestamp;
            
            logicFrame++;
            if (logicFrame % 2 === 0) {
                updateLogic(deltaTime);
            }
            
            render();
            updateStats();
            
            if (gamePhase === 'playing') {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function startSimulation() {
            const grassCount = grid.filter(t => t.grass).length;
            const rabbitCount = animals.filter(a => a.type === 'rabbit').length;
            const foxCount = animals.filter(a => a.type === 'fox').length;
            
            if (grassCount === 0 || rabbitCount === 0 || foxCount === 0) {
                alert('You need at least 1 of each organism to start!');
                return;
            }
            
            gamePhase = 'playing';
            document.getElementById('setup-controls').classList.add('hidden');
            document.getElementById('playing-controls').classList.remove('hidden');
            document.getElementById('time-stat').classList.remove('hidden');
            document.getElementById('graph-icon').classList.remove('hidden');
            document.getElementById('map-icon').classList.remove('hidden');
            document.getElementById('phase-title').textContent = 'ECOSYSTEM';
            
            lastUpdate = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function pauseSimulation() {
            if (gamePhase === 'playing') {
                gamePhase = 'paused';
                document.getElementById('pause-btn').innerHTML = '‚ñ∂Ô∏è PLAY';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            } else if (gamePhase === 'paused') {
                gamePhase = 'playing';
                document.getElementById('pause-btn').innerHTML = '‚è∏Ô∏è PAUSE';
                lastUpdate = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function resetGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            initializeGrid();
            gamePhase = 'setup';
            document.getElementById('setup-controls').classList.remove('hidden');
            document.getElementById('playing-controls').classList.add('hidden');
            document.getElementById('time-stat').classList.add('hidden');
            document.getElementById('graph-icon').classList.add('hidden');
            document.getElementById('map-icon').classList.add('hidden');
            document.getElementById('phase-title').textContent = 'SETUP PHASE';
            document.getElementById('pause-btn').innerHTML = '‚è∏Ô∏è PAUSE';
            render();
            updateStats();
        }

        function showModal(type, title, text) {
            const modal = document.getElementById('modal');
            const icon = document.getElementById('modal-icon');
            const titleEl = document.getElementById('modal-title');
            const textEl = document.getElementById('modal-text');
            const btn = document.getElementById('modal-btn');
            
            icon.textContent = type === 'victory' ? 'üèÜ' : 'üíÄ';
            titleEl.textContent = title;
            textEl.textContent = text;
            btn.textContent = type === 'victory' ? 'PLAY AGAIN' : 'TRY AGAIN';
            
            modal.classList.remove('hidden');
        }

        function hideModal() {
            document.getElementById('modal').classList.add('hidden');
            resetGame();
        }

        function placeOrganism(x, y) {
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
            
            if (selectedTool === 'grass') {
                const idx = getTileIndex(x, y);
                grid[idx] = { grass: true, grassGrowTime: 0 };
            } else {
                const occupied = animals.some(a => Math.floor(a.x) === x && Math.floor(a.y) === y);
                if (!occupied) {
                    animals.push({
                        id: nextId++,
                        type: selectedTool,
                        x: x + 0.5,
                        y: y + 0.5,
                        hunger: 0,
                        reproduceCooldown: selectedTool === 'rabbit' ? RABBIT_REPRODUCE_COOLDOWN : FOX_REPRODUCE_COOLDOWN
                    });
                }
            }
            render();
            updateStats();
        }

        canvas.addEventListener('mousedown', (e) => {
            if (gamePhase !== 'setup') return;
            const rect = canvas.getBoundingClientRect();
            const tileSize = rect.width / GRID_SIZE;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);
            placeOrganism(x, y);
        });

        canvas.addEventListener('touchstart', (e) => {
            if (gamePhase !== 'setup') return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const tileSize = rect.width / GRID_SIZE;
            const touch = e.touches[0];
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);
            placeOrganism(x, y);
        });

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => {
                    b.classList.remove('active-grass', 'active-rabbit', 'active-fox');
                });
                selectedTool = btn.dataset.tool;
                btn.classList.add(`active-${selectedTool}`);
            });
        });

        document.getElementById('trial-toggle').addEventListener('click', () => {
            trialMode = !trialMode;
            document.getElementById('trial-toggle').classList.toggle('active');
            render();
        });

        document.getElementById('start-btn').addEventListener('click', startSimulation);
        document.getElementById('clear-btn').addEventListener('click', () => {
            initializeGrid();
            render();
            updateStats();
        });
        document.getElementById('pause-btn').addEventListener('click', pauseSimulation);
        document.getElementById('reset-btn').addEventListener('click', resetGame);
        document.getElementById('modal-btn').addEventListener('click', hideModal);

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = `${speed}x`;
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            render();
        });

        initializeGrid();
        resizeCanvas();
        render();
        updateStats();
    </script>
</body>
</html>
